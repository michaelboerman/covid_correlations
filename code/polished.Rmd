---
title: "R Notebook"
output:
  html_document:
    df_print: paged
  html_notebook: default
  word_document: default
---

Set up libraries and such:
```{r, echo=FALSE, message=FALSE}
library(here)
library(readxl)
library(tidyverse)
library(lubridate)
library(scales)
library(latex2exp)
library(countrycode)

# Careful: this package is huge and has many dependencies
library(coronavirus)

# For GGplot aestehtics
library(extrafont)

```


I'd like to read in popualtion count and population density. For convienance later, I'll join them now.

The densities come from [UN Population Dynamics](https://population.un.org/wpp/Download/Standard/Population/) and are measured in 1000s.

The population count from [US Census yearly estimates](https://www.census.gov/data/datasets/time-series/demo/popest/2010s-total-cities-and-towns.html), data [found here](https://www2.census.gov/programs-surveys/popest/datasets/2010-2020/national/totals/) and is measured in 1000s
```{r, echo=FALSE}

# Read in densities
density <- read_csv(here("data_input/pop_density.csv"),
                    skip = 4) %>% 
  
  # drop everything except two, and rename while we're here
  transmute(country = `Country Name`,
            country_code = `Country Code`,
            density = `2018`) %>%
  
  # Add in the numeric country code, for use late.
  mutate(country_code_num = countrycode(country_code, 
                                  origin = "iso3c", 
                                  destination = "iso3n",
                                  nomatch = NA)) %>% 
  identity()

# Similarly, read in the full populations
pops <- read_xlsx(here("data_input/pop_count.xlsx"),
                       skip = 16) %>% 
  transmute(country = `Region, subregion, country or area *`,
            country_code_num = `Country code`,
            population = as.numeric(`2018`)) %>% 
  drop_na() %>% 
  identity()

# Join them to create one tidy dataframe
country_pops <- pops %>% 
  left_join(density, by = "country_code_num") %>% 
  
  # The population count contains more than just countries, so drop all 
  # rows in which there is no density.
  drop_na()

```


Now, let's explore some data!
```{r}
country_pops %>% 
  ggplot(aes(x = population, y = density)) +
  coord_trans(x="log10", y="log10") +
  geom_point() +
  labs(title = "Population vs Population Density of 181 Countries",
       subtitle = "Both axes log scaled",
       caption = "Desnity data from UN Population Dynamics; Population data from US Census.\nGraph by Michael Boerman, https://github.com/michaelboerman") +
  xlab(TeX("Population ($Log_{10}$)")) +
  ylab(TeX("Population Density ($Log_{10}$)")) +
  annotation_logticks(base= 10, sides = "lb", scaled = FALSE) +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank())

```
Let's look at some numbers associated with population and population density.
```{r}
# Sharpiro- Wilks test for nomrality:
#   Null hypothesis: the data are normally distributed
#   Alternative hypothesis: the data are not normally distributed
shapiro.test(country_pops$population)
shapiro.test(country_pops$density)
```
With such a low p-value for both population and population desnity, we can safely claim we have no evidence the data appear normally distributed. There's a small chance, but not much evidence.

Next, let's look at a pure pearson's correlation to see how these two move together. 
```{r}
cor.test(country_pops$population, country_pops$density, method = "pearson")
```
Look at this! The correlation is most likely 0. We have a high degree of confidence they don't move together at all. 

Now for the real meat: covid cases with density.

We need to gather covid data:
```{r}
library(COVID19)
library(countrycode)
covid_data <- COVID19::covid19() %>% 
  rename(country_code = id) %>% 
  left_join(country_pops, by = "country_code") %>% 
  identity()

covid_data %>% 
  filter(date == "2020-04-08") %>% 
  drop_na(confirmed) %>% 
  filter(confirmed > 0) %>%
  filter(density < 1000) %>% 
  filter(confirmed < 40000) %>% 
  ggplot(aes(x = deaths, y = density)) +
  coord_trans(x = "log10", y = "log10") +
  geom_point(na.rm = T) + 
  # geom_smooth(na.rm = T) +
  NULL
    
```

And for correlations:
```{r}
# un surprisngly, population and confirmed cases move together
test <- cor.test(covid_data$density, covid_data$deaths)

# shockingly, desnity and confirmed cases rarely move togehter, and if so, move opposite!
cor.test(covid_data$density, covid_data$confirmed)

date_aggregated <- 
  covid_data %>% 
  group_by(date) %>% 
  mutate(date = as.Date(date),
            new_cases = confirmed - lag(confirmed),
            cum_cases = sum(confirmed, na.rm = T),
            new_deaths = deaths - lag(deaths),
            cum_deaths = sum(deaths, na.rm = T)) %>% 
  ungroup() %>% 
  group_by(country_code) %>% 
  mutate(pop_density = sum(density)) %>% 
  ungroup() %>% 
  select(date, new_cases, cum_cases, new_deaths, cum_deaths)

n_dates <- length(date_aggregated$date)
correlation_upto <- data.frame("date" = date_aggregated$date,
                               "correlation" = rep(NA, n_dates))

# What about plotting correlations over time?
for (i in 1:n_dates) {
    
    correlation_upto$correlation[i] <-  cor(date_aggregated$density[1:i], 
                                            date_aggregated$cum_cases[1:i], 
                                            use = "complete.obs")
}
  
date_aggregated %>% 
  ggplot(aes(x=date)) +
  geom_line(aes(y = cum_cases))
```


```{r}

# Grab the individual dates out of our long dataframe
  unique_dates <- unique(covid_data$date)

# sort by date, such that Jan 2021 will come at the end, not beginning
  unique_dates <- unique_dates[order(unique_dates)]

# skip Jan 2020
  unique_dates <- unique_dates[33:length(unique_dates)-1]
  
# I can't wait for R 4.1 native pipes... :)

# initialize a DF to put in each date's correlation
  cors_over_time <- data.frame(
    "date" = unique_dates,
    "death_cor" = rep(NA, length(unique_dates)),
    "case_cor" = rep(NA, length(unique_dates))
    )
# for loop for calculating correlation per date
  for (i in 1:length(unique_dates)) {
    
    # grab the data frame for that date i
    filtered_date_data <- covid_data %>% 
      filter(date == unique_dates[i]) %>% 
      identity()
    
    # insert correlation between pop density and deaths
    cors_over_time$death_cor[i] <- cor(filtered_date_data$density, filtered_date_data$deaths, use = "complete.obs")
    
    # insert correlation between pop density and confirmed cases
    cors_over_time$case_cor[i] <- cor(filtered_date_data$density, filtered_date_data$confirmed, use = "complete.obs")
    
  }

```

Now, let's plot!
```{r}
# plot for correlation between pop density adn deaths
variable_to_plot <- "death_cor"

cors_over_time %>% 
  ggplot(aes(x = date))+
  geom_line(aes(y = get(variable_to_plot))) + 
  theme_minimal() +
  geom_hline(yintercept = 0)+
  geom_hline(yintercept = mean(get(cors_over_time$`variable_to_plot`)),
             linetype = "dashed", color = "gray")+
  scale_y_continuous(expand = expand_scale(mult = 0),
                     limits = c(-0.25, 0)) +
  scale_x_date(expand = expand_scale(mult = 0)) +
  labs(title = "Correlation between Population Density and COVID Deaths",
       subtitle = "Filtered by date",
       caption = "Source: UN Population Dynamics, Oxford COVID-19 Government Response Tracker. \n Chart: Michael Boerman, https://github.com/michaelboerman") +
  theme(text = element_text(family="TT Times New Roman"),
        axis.title.x = element_blank(),
        axis.title.y = element_text("Correlation"),
        axis.line.y = element_line())
```

Repeat, but for covid cases:
```{r}


cors_over_time %>% 
  ggplot(aes(x = date))+
  geom_line(aes(y = case_cor)) + 
  theme_minimal() +
  geom_hline(yintercept = 0)+
  geom_hline(yintercept = mean(cors_over_time$case_cor),
             linetype = "dashed", color = "gray")+
  scale_y_continuous(expand = expand_scale(mult = 0),
                     limits = c(-0.25, 0)) +
  scale_x_date(expand = expand_scale(mult = 0)) +
  labs(title = "Correlation between Population Density and COVID Deaths",
       subtitle = "Filtered by date",
       caption = "Source: UN Population Dynamics, Oxford COVID-19 Government Response Tracker. \n Chart: Michael Boerman, https://github.com/michaelboerman") +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_text("Correlation"),
        axis.line.y = element_line())
```

